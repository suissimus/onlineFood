//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.2.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IParkingsClient {
    /**
     * Return all cities that have aprking zones
     * @param api_version (optional) 
     */
    getParkingCities(api_version?: string | null | undefined): Observable<Result<GetParkingCitiesResponse>>;
    /**
     * Add new Parking City
     * @param api_version (optional) 
     */
    createParkingCity(request: CreateParkingCityCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Delete Parking City
     * @param api_version (optional) 
     */
    deleteParkingCity(request: DeleteParkingCityCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Edit Parking City)
     * @param api_version (optional) 
     */
    editParkingCity(request: EditParkingCityCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Get All Parking Zones For City
     * @param cityId (optional) 
     * @param api_version (optional) 
     */
    getAllParkingZones(cityId?: string | undefined, api_version?: string | null | undefined): Observable<Result<GetParkingZonesResponse>>;
    /**
     * Create New Parking Zone
     * @param api_version (optional) 
     */
    createParkingZone(request: CreateParkingZoneCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Delete Parking Zone
     * @param api_version (optional) 
     */
    deleteParkingZone(request: DeleteParkingZoneCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Edit parking zone
     * @param api_version (optional) 
     */
    editParkingZone(request: EditParkingZoneCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class ParkingsClient implements IParkingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Return all cities that have aprking zones
     * @param api_version (optional) 
     */
    getParkingCities(api_version?: string | null | undefined): Observable<Result<GetParkingCitiesResponse>> {
        let url_ = this.baseUrl + "/api/parkings/get-parking-cities?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParkingCities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParkingCities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetParkingCitiesResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetParkingCitiesResponse>>;
        }));
    }

    protected processGetParkingCities(response: HttpResponseBase): Observable<Result<GetParkingCitiesResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetParkingCitiesResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetParkingCitiesResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * Add new Parking City
     * @param api_version (optional) 
     */
    createParkingCity(request: CreateParkingCityCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/parkings/add-parking-city?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateParkingCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateParkingCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processCreateParkingCity(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Delete Parking City
     * @param api_version (optional) 
     */
    deleteParkingCity(request: DeleteParkingCityCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/parkings/remove-parking-city?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteParkingCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteParkingCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processDeleteParkingCity(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Edit Parking City)
     * @param api_version (optional) 
     */
    editParkingCity(request: EditParkingCityCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/parkings/edit-parking-city?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditParkingCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditParkingCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processEditParkingCity(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Get All Parking Zones For City
     * @param cityId (optional) 
     * @param api_version (optional) 
     */
    getAllParkingZones(cityId?: string | undefined, api_version?: string | null | undefined): Observable<Result<GetParkingZonesResponse>> {
        let url_ = this.baseUrl + "/api/parkings/get-parking-zones?";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "cityId=" + encodeURIComponent("" + cityId) + "&";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllParkingZones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllParkingZones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetParkingZonesResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetParkingZonesResponse>>;
        }));
    }

    protected processGetAllParkingZones(response: HttpResponseBase): Observable<Result<GetParkingZonesResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetParkingZonesResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetParkingZonesResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * Create New Parking Zone
     * @param api_version (optional) 
     */
    createParkingZone(request: CreateParkingZoneCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/parkings/add-parking-zone?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateParkingZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateParkingZone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processCreateParkingZone(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Delete Parking Zone
     * @param api_version (optional) 
     */
    deleteParkingZone(request: DeleteParkingZoneCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/parkings/remove-parking-zone?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteParkingZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteParkingZone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processDeleteParkingZone(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Edit parking zone
     * @param api_version (optional) 
     */
    editParkingZone(request: EditParkingZoneCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/parkings/edit-parking-zone?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditParkingZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditParkingZone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processEditParkingZone(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface IClient {
    get_All_Vehicle_Types(api_version?: string | null | undefined): Observable<Result<GetVehicleTypesResponse>>;
    get_All_Vehicle_Brands_for_specific_type(vehicleTypeId?: string | undefined, api_version?: string | null | undefined): Observable<Result<GetVehicleBrandsResponse>>;
    get_All_Vehicle_Models_for_specific_brand(brandId?: string | undefined, api_version?: string | null | undefined): Observable<Result<GetModelsForBrandQueryResponse>>;
    edit_Package(request: EditPackageCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    upload_package_image(api_version?: string | null | undefined, image?: FileParameter | null | undefined, packageId?: string | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    get_All_Vehicle_Types(api_version?: string | null | undefined): Observable<Result<GetVehicleTypesResponse>> {
        let url_ = this.baseUrl + "/api/vehicles/get-vehicle-types?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_All_Vehicle_Types(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_All_Vehicle_Types(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetVehicleTypesResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetVehicleTypesResponse>>;
        }));
    }

    protected processGet_All_Vehicle_Types(response: HttpResponseBase): Observable<Result<GetVehicleTypesResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVehicleTypesResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetVehicleTypesResponse>>(new Result(status, _headers, null as any));
    }

    get_All_Vehicle_Brands_for_specific_type(vehicleTypeId?: string | undefined, api_version?: string | null | undefined): Observable<Result<GetVehicleBrandsResponse>> {
        let url_ = this.baseUrl + "/api/vehicles/get-vehicle-brands-for-type?";
        if (vehicleTypeId === null)
            throw new Error("The parameter 'vehicleTypeId' cannot be null.");
        else if (vehicleTypeId !== undefined)
            url_ += "vehicleTypeId=" + encodeURIComponent("" + vehicleTypeId) + "&";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_All_Vehicle_Brands_for_specific_type(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_All_Vehicle_Brands_for_specific_type(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetVehicleBrandsResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetVehicleBrandsResponse>>;
        }));
    }

    protected processGet_All_Vehicle_Brands_for_specific_type(response: HttpResponseBase): Observable<Result<GetVehicleBrandsResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVehicleBrandsResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetVehicleBrandsResponse>>(new Result(status, _headers, null as any));
    }

    get_All_Vehicle_Models_for_specific_brand(brandId?: string | undefined, api_version?: string | null | undefined): Observable<Result<GetModelsForBrandQueryResponse>> {
        let url_ = this.baseUrl + "/api/vehicles/get-vehicle-models-for-brand?";
        if (brandId === null)
            throw new Error("The parameter 'brandId' cannot be null.");
        else if (brandId !== undefined)
            url_ += "brandId=" + encodeURIComponent("" + brandId) + "&";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_All_Vehicle_Models_for_specific_brand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_All_Vehicle_Models_for_specific_brand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetModelsForBrandQueryResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetModelsForBrandQueryResponse>>;
        }));
    }

    protected processGet_All_Vehicle_Models_for_specific_brand(response: HttpResponseBase): Observable<Result<GetModelsForBrandQueryResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetModelsForBrandQueryResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetModelsForBrandQueryResponse>>(new Result(status, _headers, null as any));
    }

    edit_Package(request: EditPackageCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/packages/edit-package?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit_Package(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit_Package(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processEdit_Package(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    upload_package_image(api_version?: string | null | undefined, image?: FileParameter | null | undefined, packageId?: string | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/packages/upload-image?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (image !== null && image !== undefined)
            content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
        if (packageId === null || packageId === undefined)
            throw new Error("The parameter 'packageId' cannot be null.");
        else
            content_.append("PackageId", packageId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload_package_image(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload_package_image(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processUpload_package_image(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface IVehiclesClient {
    /**
     * Get all user vehicles
     * @param api_version (optional) 
     */
    getUserVehicles(api_version?: string | null | undefined): Observable<Result<GetVehiclesQueryResponse>>;
    /**
     * Get single vehicle
     * @param vehicleId (optional) 
     * @param api_version (optional) 
     */
    getVehicle(vehicleId?: string | undefined, api_version?: string | null | undefined): Observable<Result<GetVehicleQueryResponse>>;
    /**
     * Retrieves number of packages per vehicle type.
     * @param api_version (optional) 
     */
    getPackagesCountPerVehicleType(api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Link new licence plate for a user
     * @param api_version (optional) 
     */
    addLicencePlate(request: AddLicencePlateCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Delete licence plate
     * @param api_version (optional) 
     */
    deleteLicencePlate(request: DeleteLicencePlateCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class VehiclesClient implements IVehiclesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all user vehicles
     * @param api_version (optional) 
     */
    getUserVehicles(api_version?: string | null | undefined): Observable<Result<GetVehiclesQueryResponse>> {
        let url_ = this.baseUrl + "/api/vehicles/get-user-vehicles?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserVehicles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserVehicles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetVehiclesQueryResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetVehiclesQueryResponse>>;
        }));
    }

    protected processGetUserVehicles(response: HttpResponseBase): Observable<Result<GetVehiclesQueryResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVehiclesQueryResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetVehiclesQueryResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * Get single vehicle
     * @param vehicleId (optional) 
     * @param api_version (optional) 
     */
    getVehicle(vehicleId?: string | undefined, api_version?: string | null | undefined): Observable<Result<GetVehicleQueryResponse>> {
        let url_ = this.baseUrl + "/api/vehicles/get-vehicle?";
        if (vehicleId === null)
            throw new Error("The parameter 'vehicleId' cannot be null.");
        else if (vehicleId !== undefined)
            url_ += "vehicleId=" + encodeURIComponent("" + vehicleId) + "&";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetVehicleQueryResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetVehicleQueryResponse>>;
        }));
    }

    protected processGetVehicle(response: HttpResponseBase): Observable<Result<GetVehicleQueryResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVehicleQueryResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetVehicleQueryResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * Retrieves number of packages per vehicle type.
     * @param api_version (optional) 
     */
    getPackagesCountPerVehicleType(api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/vehicles/get-packages-count?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackagesCountPerVehicleType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackagesCountPerVehicleType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetPackagesCountPerVehicleType(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Link new licence plate for a user
     * @param api_version (optional) 
     */
    addLicencePlate(request: AddLicencePlateCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/vehicles/add-licence-plate?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLicencePlate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLicencePlate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processAddLicencePlate(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Delete licence plate
     * @param api_version (optional) 
     */
    deleteLicencePlate(request: DeleteLicencePlateCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/vehicles/remove-licence-plate?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLicencePlate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLicencePlate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processDeleteLicencePlate(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface IClientClient {
    /**
     * Register client person account
     * @param api_version (optional) 
     */
    registerClientPerson(request: RegisterClientPersonCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Create new vehicle for user
     * @param api_version (optional) 
     */
    addVehicle(request: AddVehicleCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Update user vehicle
     * @param api_version (optional) 
     */
    updateVehicle(request: UpdateVehicleCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class ClientClient implements IClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Register client person account
     * @param api_version (optional) 
     */
    registerClientPerson(request: RegisterClientPersonCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/client/register-client-person?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterClientPerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterClientPerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processRegisterClientPerson(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Create new vehicle for user
     * @param api_version (optional) 
     */
    addVehicle(request: AddVehicleCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/client/create-user-vehicle?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVehicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processAddVehicle(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Update user vehicle
     * @param api_version (optional) 
     */
    updateVehicle(request: UpdateVehicleCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/client/update-user-vehicle?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVehicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processUpdateVehicle(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface IUsersClient {
    /**
     * Returns user's profile information
     * @param api_version (optional) 
     */
    getProfile(api_version?: string | null | undefined): Observable<Result<GetProfileResponse>>;
    /**
     * Updates user's profile information
     * @param api_version (optional) 
     */
    updateProfile(command: UpdateProfileCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Request a verification email for a user registration.
     * @param api_version (optional) 
     */
    verifyRegistrationEmail(request: VerifyRegistrationEmailCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Request a pasword reset email for a user.
     * @param api_version (optional) 
     */
    verifyPasswordResetEmail(request: VerifyPasswordResetEmailCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Reset a user's password.
     * @param api_version (optional) 
     */
    resetPassword(request: ResetPasswordCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Change a user's password.
     * @param api_version (optional) 
     */
    changePassword(request: ChangePasswordCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Returns user's profile information
     * @param api_version (optional) 
     */
    getProfile(api_version?: string | null | undefined): Observable<Result<GetProfileResponse>> {
        let url_ = this.baseUrl + "/api/users/get-profile?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetProfileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetProfileResponse>>;
        }));
    }

    protected processGetProfile(response: HttpResponseBase): Observable<Result<GetProfileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfileResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetProfileResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * Updates user's profile information
     * @param api_version (optional) 
     */
    updateProfile(command: UpdateProfileCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/users/update-profile?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Request a verification email for a user registration.
     * @param api_version (optional) 
     */
    verifyRegistrationEmail(request: VerifyRegistrationEmailCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/users/verify-registration?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyRegistrationEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyRegistrationEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processVerifyRegistrationEmail(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Request a pasword reset email for a user.
     * @param api_version (optional) 
     */
    verifyPasswordResetEmail(request: VerifyPasswordResetEmailCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/users/verify-password-reset?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyPasswordResetEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyPasswordResetEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processVerifyPasswordResetEmail(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Reset a user's password.
     * @param api_version (optional) 
     */
    resetPassword(request: ResetPasswordCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/users/reset-password?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Change a user's password.
     * @param api_version (optional) 
     */
    changePassword(request: ChangePasswordCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/users/change-password?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface IPartnersClient {
    /**
     * Get all partners table
     * @param api_version (optional) 
     */
    getPartnersTable(request: GetPartnersQuery, api_version?: string | null | undefined): Observable<Result<GetPartnersResponse>>;
    /**
     * activate partner account
     * @param api_version (optional) 
     */
    activatePartner(request: ActivatePartnersCommand, api_version?: string | null | undefined): Observable<Result<GetPartnersResponse>>;
    /**
     * deactivate partner account
     * @param api_version (optional) 
     */
    deactivatePartner(request: DeactivatePartnersCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Edit partner profile
     * @param api_version (optional) 
     */
    editPartner(request: EditPartnerCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * deactivate partner account
     * @param api_version (optional) 
     */
    testFirebase(api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Create new partner
     * @param api_version (optional) 
     */
    createPartner(request: CreatePartnerCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class PartnersClient implements IPartnersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all partners table
     * @param api_version (optional) 
     */
    getPartnersTable(request: GetPartnersQuery, api_version?: string | null | undefined): Observable<Result<GetPartnersResponse>> {
        let url_ = this.baseUrl + "/api/partners/get-partners-table?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnersTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnersTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetPartnersResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetPartnersResponse>>;
        }));
    }

    protected processGetPartnersTable(response: HttpResponseBase): Observable<Result<GetPartnersResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPartnersResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetPartnersResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * activate partner account
     * @param api_version (optional) 
     */
    activatePartner(request: ActivatePartnersCommand, api_version?: string | null | undefined): Observable<Result<GetPartnersResponse>> {
        let url_ = this.baseUrl + "/api/partners/activate-partner?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivatePartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivatePartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<GetPartnersResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<GetPartnersResponse>>;
        }));
    }

    protected processActivatePartner(response: HttpResponseBase): Observable<Result<GetPartnersResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPartnersResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<GetPartnersResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * deactivate partner account
     * @param api_version (optional) 
     */
    deactivatePartner(request: DeactivatePartnersCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/partners/deactivate-partner?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivatePartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivatePartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processDeactivatePartner(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Edit partner profile
     * @param api_version (optional) 
     */
    editPartner(request: EditPartnerCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/partners/edit-partner?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processEditPartner(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * deactivate partner account
     * @param api_version (optional) 
     */
    testFirebase(api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/partners/test-firebase?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestFirebase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestFirebase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processTestFirebase(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Create new partner
     * @param api_version (optional) 
     */
    createPartner(request: CreatePartnerCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/partners/create-partner?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processCreatePartner(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface IPackagesClient {
    /**
     * Retrieves all public packages.
     * @param api_version (optional) 
     */
    getPublicPackages(api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Retrieves all recommended active packages.
     * @param packageId (optional) 
     * @param api_version (optional) 
     */
    getRecommendedActive(packageId?: string[] | undefined, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Create new package.
     * @param api_version (optional) 
     */
    createPackage(request: CreatePackageCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Retrieves all services.
     * @param api_version (optional) 
     */
    getAllServices(api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Retrieves package details.
     * @param api_version (optional) 
     */
    getPackageDetails(api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Retrieves all packages per vehicle type.
     * @param vehicleTypeIds (optional) 
     * @param api_version (optional) 
     */
    getPackagesPerVehicleType(vehicleTypeIds?: string[] | undefined, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Retrieves single package
     * @param packageId (optional) 
     * @param api_version (optional) 
     */
    getPackage(packageId?: string | undefined, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class PackagesClient implements IPackagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Retrieves all public packages.
     * @param api_version (optional) 
     */
    getPublicPackages(api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/packages/get-public?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublicPackages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublicPackages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetPublicPackages(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Retrieves all recommended active packages.
     * @param packageId (optional) 
     * @param api_version (optional) 
     */
    getRecommendedActive(packageId?: string[] | undefined, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/packages/get-recommended-active?";
        if (packageId === null)
            throw new Error("The parameter 'packageId' cannot be null.");
        else if (packageId !== undefined)
            packageId && packageId.forEach(item => { url_ += "packageId=" + encodeURIComponent("" + item) + "&"; });
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecommendedActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecommendedActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetRecommendedActive(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Create new package.
     * @param api_version (optional) 
     */
    createPackage(request: CreatePackageCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/packages/create-package?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePackage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processCreatePackage(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Retrieves all services.
     * @param api_version (optional) 
     */
    getAllServices(api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/packages/get-all-services?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllServices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetAllServices(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Retrieves package details.
     * @param api_version (optional) 
     */
    getPackageDetails(api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/packages/get-package-details?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackageDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackageDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetPackageDetails(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Retrieves all packages per vehicle type.
     * @param vehicleTypeIds (optional) 
     * @param api_version (optional) 
     */
    getPackagesPerVehicleType(vehicleTypeIds?: string[] | undefined, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/packages/get-packages-vehicle-type?";
        if (vehicleTypeIds === null)
            throw new Error("The parameter 'vehicleTypeIds' cannot be null.");
        else if (vehicleTypeIds !== undefined)
            vehicleTypeIds && vehicleTypeIds.forEach(item => { url_ += "vehicleTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackagesPerVehicleType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackagesPerVehicleType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetPackagesPerVehicleType(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Retrieves single package
     * @param packageId (optional) 
     * @param api_version (optional) 
     */
    getPackage(packageId?: string | undefined, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/packages/get-package?";
        if (packageId === null)
            throw new Error("The parameter 'packageId' cannot be null.");
        else if (packageId !== undefined)
            url_ += "packageId=" + encodeURIComponent("" + packageId) + "&";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetPackage(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface IOrdersClient {
    /**
     * Create new order
     * @param api_version (optional) 
     */
    createOrder(request: CreateOrderCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class OrdersClient implements IOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Create new order
     * @param api_version (optional) 
     */
    createOrder(request: CreateOrderCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/orders/create-order?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processCreateOrder(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface INotificationsClient {
    /**
     * Get user notifications
     * @param api_version (optional) 
     */
    getUserNotifications(api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class NotificationsClient implements INotificationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get user notifications
     * @param api_version (optional) 
     */
    getUserNotifications(api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/notifications/get-user-notifications?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface ITokensClient {
    /**
     * Returns login token
     * @param api_version (optional) 
     */
    getToken(request: LoginCommand, api_version?: string | null | undefined): Observable<Result<TokenResponse>>;
    /**
     * Returns login token for external provider
     * @param api_version (optional) 
     */
    externalLogin(request: ExternalLoginCommand, api_version?: string | null | undefined): Observable<Result<TokenResponse>>;
    /**
     * Request an access token using a refresh token.
     * @param api_version (optional) 
     */
    refresh(request: RefreshTokenCommand, api_version?: string | null | undefined): Observable<Result<TokenResponse>>;
    /**
     * Returns login token for apple provider
     * @param api_version (optional) 
     */
    appleLogin(request: AppleLoginCommand, api_version?: string | null | undefined): Observable<Result<TokenResponse>>;
    /**
     * Logout
     * @param api_version (optional) 
     */
    logout(api_version?: string | null | undefined): Observable<Result<TokenResponse>>;
}

@Injectable({
    providedIn: 'root'
})
export class TokensClient implements ITokensClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Returns login token
     * @param api_version (optional) 
     */
    getToken(request: LoginCommand, api_version?: string | null | undefined): Observable<Result<TokenResponse>> {
        let url_ = this.baseUrl + "/api/tokens/login?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<TokenResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<TokenResponse>>;
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<Result<TokenResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorResult.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<TokenResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * Returns login token for external provider
     * @param api_version (optional) 
     */
    externalLogin(request: ExternalLoginCommand, api_version?: string | null | undefined): Observable<Result<TokenResponse>> {
        let url_ = this.baseUrl + "/api/tokens/external-login?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<TokenResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<TokenResponse>>;
        }));
    }

    protected processExternalLogin(response: HttpResponseBase): Observable<Result<TokenResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorResult.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<TokenResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * Request an access token using a refresh token.
     * @param api_version (optional) 
     */
    refresh(request: RefreshTokenCommand, api_version?: string | null | undefined): Observable<Result<TokenResponse>> {
        let url_ = this.baseUrl + "/api/tokens/refresh?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<TokenResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<TokenResponse>>;
        }));
    }

    protected processRefresh(response: HttpResponseBase): Observable<Result<TokenResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorResult.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<TokenResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * Returns login token for apple provider
     * @param api_version (optional) 
     */
    appleLogin(request: AppleLoginCommand, api_version?: string | null | undefined): Observable<Result<TokenResponse>> {
        let url_ = this.baseUrl + "/api/tokens/apple-login?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAppleLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAppleLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<TokenResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<TokenResponse>>;
        }));
    }

    protected processAppleLogin(response: HttpResponseBase): Observable<Result<TokenResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorResult.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<TokenResponse>>(new Result(status, _headers, null as any));
    }

    /**
     * Logout
     * @param api_version (optional) 
     */
    logout(api_version?: string | null | undefined): Observable<Result<TokenResponse>> {
        let url_ = this.baseUrl + "/api/tokens/logout?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<TokenResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<TokenResponse>>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<Result<TokenResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenResponse.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResult.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<TokenResponse>>(new Result(status, _headers, null as any));
    }
}

export interface IEmployeesClient {
    /**
     * Get all company employees
     * @param api_version (optional) 
     */
    getAllEmployees(request: GetEmployeesTableQuery, api_version?: string | null | undefined): Observable<Result<PaginationResponseOfEmployeeItem>>;
    /**
     * Sends invites to new employees
     * @param api_version (optional) 
     */
    inviteNewEmployees(request: InviteNewEmployeesCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * deactivates employee
     * @param api_version (optional) 
     */
    deactivateEmployee(request: DeactivateEmployeesCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * ativates employee
     * @param api_version (optional) 
     */
    activateEmployee(request: ActivateEmployeeAsyncCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Edit employee account
     * @param api_version (optional) 
     */
    editEmployee(request: EditEmployeeCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class EmployeesClient implements IEmployeesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all company employees
     * @param api_version (optional) 
     */
    getAllEmployees(request: GetEmployeesTableQuery, api_version?: string | null | undefined): Observable<Result<PaginationResponseOfEmployeeItem>> {
        let url_ = this.baseUrl + "/api/employees/get-all-employees?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<PaginationResponseOfEmployeeItem>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<PaginationResponseOfEmployeeItem>>;
        }));
    }

    protected processGetAllEmployees(response: HttpResponseBase): Observable<Result<PaginationResponseOfEmployeeItem>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginationResponseOfEmployeeItem.fromJS(resultData200);
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<PaginationResponseOfEmployeeItem>>(new Result(status, _headers, null as any));
    }

    /**
     * Sends invites to new employees
     * @param api_version (optional) 
     */
    inviteNewEmployees(request: InviteNewEmployeesCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/employees/invite-new-employees?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInviteNewEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInviteNewEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processInviteNewEmployees(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * deactivates employee
     * @param api_version (optional) 
     */
    deactivateEmployee(request: DeactivateEmployeesCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/employees/deactivate-employee?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processDeactivateEmployee(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * ativates employee
     * @param api_version (optional) 
     */
    activateEmployee(request: ActivateEmployeeAsyncCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/employees/activate-employee?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processActivateEmployee(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Edit employee account
     * @param api_version (optional) 
     */
    editEmployee(request: EditEmployeeCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/employees/edit-employee?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processEditEmployee(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface IMediumsClient {
    /**
     * Create new medium
     * @param api_version (optional) 
     */
    createMedium(request: CreateMediumCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Retrieves all mediums.
     * @param api_version (optional) 
     */
    getMediums(api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Removes medium
     * @param api_version (optional) 
     */
    deleteMedium(request: DeleteMediumCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Edit medium
     * @param api_version (optional) 
     */
    editMedium(request: EditMediumCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class MediumsClient implements IMediumsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Create new medium
     * @param api_version (optional) 
     */
    createMedium(request: CreateMediumCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/mediums/create-medium?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMedium(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMedium(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processCreateMedium(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Retrieves all mediums.
     * @param api_version (optional) 
     */
    getMediums(api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/mediums/get-mediums?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMediums(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMediums(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetMediums(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Removes medium
     * @param api_version (optional) 
     */
    deleteMedium(request: DeleteMediumCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/mediums/remove-medium?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMedium(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMedium(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processDeleteMedium(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Edit medium
     * @param api_version (optional) 
     */
    editMedium(request: EditMediumCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/mediums/edit-medium?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditMedium(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditMedium(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processEditMedium(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface ISourcesClient {
    /**
     * Create new source
     * @param api_version (optional) 
     */
    createSource(request: CreateSourceCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Retrieves all sources.
     * @param api_version (optional) 
     */
    getSources(api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Removes source
     * @param api_version (optional) 
     */
    deleteSource(request: DeleteSourceCommand, api_version?: string | null | undefined): Observable<Result<string>>;
    /**
     * Edit source
     * @param api_version (optional) 
     */
    editSource(request: EditSourceCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class SourcesClient implements ISourcesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Create new source
     * @param api_version (optional) 
     */
    createSource(request: CreateSourceCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/sources/create-source?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processCreateSource(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Retrieves all sources.
     * @param api_version (optional) 
     */
    getSources(api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/sources/get-sources?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processGetSources(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Removes source
     * @param api_version (optional) 
     */
    deleteSource(request: DeleteSourceCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/sources/remove-source?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processDeleteSource(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }

    /**
     * Edit source
     * @param api_version (optional) 
     */
    editSource(request: EditSourceCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/sources/edit-source?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processEditSource(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export interface IAssistancesClient {
    /**
     * CreateAssistance
     * @param api_version (optional) 
     */
    createAssistance(request: CreateAssistanceCommand, api_version?: string | null | undefined): Observable<Result<string>>;
}

@Injectable({
    providedIn: 'root'
})
export class AssistancesClient implements IAssistancesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * CreateAssistance
     * @param api_version (optional) 
     */
    createAssistance(request: CreateAssistanceCommand, api_version?: string | null | undefined): Observable<Result<string>> {
        let url_ = this.baseUrl + "/api/assistances/create-assistance?";
        if (api_version !== undefined && api_version !== null)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAssistance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAssistance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result<string>>;
        }));
    }

    protected processCreateAssistance(response: HttpResponseBase): Observable<Result<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new Result(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result<string>>(new Result(status, _headers, null as any));
    }
}

export class GetParkingCitiesResponse implements IGetParkingCitiesResponse {
    responseList?: ParkingCityItem[];

    constructor(data?: IGetParkingCitiesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["responseList"])) {
                this.responseList = [] as any;
                for (let item of _data["responseList"])
                    this.responseList!.push(ParkingCityItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetParkingCitiesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetParkingCitiesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.responseList)) {
            data["responseList"] = [];
            for (let item of this.responseList)
                data["responseList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetParkingCitiesResponse {
    responseList?: ParkingCityItem[];
}

export class ParkingCityItem implements IParkingCityItem {
    cityId?: string;
    cityName?: string;

    constructor(data?: IParkingCityItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cityId = _data["cityId"];
            this.cityName = _data["cityName"];
        }
    }

    static fromJS(data: any): ParkingCityItem {
        data = typeof data === 'object' ? data : {};
        let result = new ParkingCityItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId;
        data["cityName"] = this.cityName;
        return data;
    }
}

export interface IParkingCityItem {
    cityId?: string;
    cityName?: string;
}

export class CreateParkingCityCommand implements ICreateParkingCityCommand {
    name!: string;

    constructor(data?: ICreateParkingCityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateParkingCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateParkingCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateParkingCityCommand {
    name: string;
}

export class DeleteParkingCityCommand implements IDeleteParkingCityCommand {
    parkingCityId!: string;

    constructor(data?: IDeleteParkingCityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parkingCityId = _data["parkingCityId"];
        }
    }

    static fromJS(data: any): DeleteParkingCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteParkingCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parkingCityId"] = this.parkingCityId;
        return data;
    }
}

export interface IDeleteParkingCityCommand {
    parkingCityId: string;
}

export class EditParkingCityCommand implements IEditParkingCityCommand {
    cityId!: string;
    cityName!: string;

    constructor(data?: IEditParkingCityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cityId = _data["cityId"];
            this.cityName = _data["cityName"];
        }
    }

    static fromJS(data: any): EditParkingCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditParkingCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId;
        data["cityName"] = this.cityName;
        return data;
    }
}

export interface IEditParkingCityCommand {
    cityId: string;
    cityName: string;
}

export class GetParkingZonesResponse implements IGetParkingZonesResponse {
    responseList?: ParkingZoneItem[];

    constructor(data?: IGetParkingZonesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["responseList"])) {
                this.responseList = [] as any;
                for (let item of _data["responseList"])
                    this.responseList!.push(ParkingZoneItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetParkingZonesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetParkingZonesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.responseList)) {
            data["responseList"] = [];
            for (let item of this.responseList)
                data["responseList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetParkingZonesResponse {
    responseList?: ParkingZoneItem[];
}

export class ParkingZoneItem implements IParkingZoneItem {
    id?: string;
    name?: string;
    description?: string;
    phoneNumber?: string;
    color?: ZoneColor;
    type?: ZoneType;

    constructor(data?: IParkingZoneItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.phoneNumber = _data["phoneNumber"];
            this.color = _data["color"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ParkingZoneItem {
        data = typeof data === 'object' ? data : {};
        let result = new ParkingZoneItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["phoneNumber"] = this.phoneNumber;
        data["color"] = this.color;
        data["type"] = this.type;
        return data;
    }
}

export interface IParkingZoneItem {
    id?: string;
    name?: string;
    description?: string;
    phoneNumber?: string;
    color?: ZoneColor;
    type?: ZoneType;
}

export enum ZoneColor {
    PLAVA = 1,
    ZELENA = 2,
    ZUTA = 3,
    LJUBICASTA = 4,
    SIVA = 5,
    CRVENA = 6,
    ZLATNA = 7,
    BELA = 8,
}

export enum ZoneType {
    PO_SATU = 1,
    DNEVNA = 2,
}

export class CreateParkingZoneCommand implements ICreateParkingZoneCommand {
    name!: string;
    description!: string;
    phoneNumber!: string;
    cityId!: string;
    color!: ZoneColor;
    zoneType!: ZoneType;

    constructor(data?: ICreateParkingZoneCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.phoneNumber = _data["phoneNumber"];
            this.cityId = _data["cityId"];
            this.color = _data["color"];
            this.zoneType = _data["zoneType"];
        }
    }

    static fromJS(data: any): CreateParkingZoneCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateParkingZoneCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["phoneNumber"] = this.phoneNumber;
        data["cityId"] = this.cityId;
        data["color"] = this.color;
        data["zoneType"] = this.zoneType;
        return data;
    }
}

export interface ICreateParkingZoneCommand {
    name: string;
    description: string;
    phoneNumber: string;
    cityId: string;
    color: ZoneColor;
    zoneType: ZoneType;
}

export class DeleteParkingZoneCommand implements IDeleteParkingZoneCommand {
    zoneId!: string;

    constructor(data?: IDeleteParkingZoneCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zoneId = _data["zoneId"];
        }
    }

    static fromJS(data: any): DeleteParkingZoneCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteParkingZoneCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zoneId"] = this.zoneId;
        return data;
    }
}

export interface IDeleteParkingZoneCommand {
    zoneId: string;
}

export class EditParkingZoneCommand implements IEditParkingZoneCommand {
    zoneId?: string;
    name!: string;
    phoneNumber!: string;
    description!: string;
    cityId!: string;
    color!: ZoneColor;
    type!: ZoneType;

    constructor(data?: IEditParkingZoneCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zoneId = _data["zoneId"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.description = _data["description"];
            this.cityId = _data["cityId"];
            this.color = _data["color"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): EditParkingZoneCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditParkingZoneCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zoneId"] = this.zoneId;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["description"] = this.description;
        data["cityId"] = this.cityId;
        data["color"] = this.color;
        data["type"] = this.type;
        return data;
    }
}

export interface IEditParkingZoneCommand {
    zoneId?: string;
    name: string;
    phoneNumber: string;
    description: string;
    cityId: string;
    color: ZoneColor;
    type: ZoneType;
}

export class GetVehicleTypesResponse implements IGetVehicleTypesResponse {
    responseList?: VehicleTypeItem[];

    constructor(data?: IGetVehicleTypesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["responseList"])) {
                this.responseList = [] as any;
                for (let item of _data["responseList"])
                    this.responseList!.push(VehicleTypeItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetVehicleTypesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetVehicleTypesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.responseList)) {
            data["responseList"] = [];
            for (let item of this.responseList)
                data["responseList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetVehicleTypesResponse {
    responseList?: VehicleTypeItem[];
}

export class VehicleTypeItem implements IVehicleTypeItem {
    typeId?: string;
    name?: string;

    constructor(data?: IVehicleTypeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): VehicleTypeItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleTypeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        return data;
    }
}

export interface IVehicleTypeItem {
    typeId?: string;
    name?: string;
}

export class GetVehicleBrandsResponse implements IGetVehicleBrandsResponse {
    responseList?: VehicleBrandItem[];

    constructor(data?: IGetVehicleBrandsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["responseList"])) {
                this.responseList = [] as any;
                for (let item of _data["responseList"])
                    this.responseList!.push(VehicleBrandItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetVehicleBrandsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetVehicleBrandsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.responseList)) {
            data["responseList"] = [];
            for (let item of this.responseList)
                data["responseList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetVehicleBrandsResponse {
    responseList?: VehicleBrandItem[];
}

export class VehicleBrandItem implements IVehicleBrandItem {
    brandId?: string;
    name?: string;

    constructor(data?: IVehicleBrandItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): VehicleBrandItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleBrandItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["name"] = this.name;
        return data;
    }
}

export interface IVehicleBrandItem {
    brandId?: string;
    name?: string;
}

export class GetModelsForBrandQueryResponse implements IGetModelsForBrandQueryResponse {
    responseList?: BrandModelItem[];

    constructor(data?: IGetModelsForBrandQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["responseList"])) {
                this.responseList = [] as any;
                for (let item of _data["responseList"])
                    this.responseList!.push(BrandModelItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetModelsForBrandQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetModelsForBrandQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.responseList)) {
            data["responseList"] = [];
            for (let item of this.responseList)
                data["responseList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetModelsForBrandQueryResponse {
    responseList?: BrandModelItem[];
}

export class BrandModelItem implements IBrandModelItem {
    modelId?: string;
    name?: string;

    constructor(data?: IBrandModelItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modelId = _data["modelId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BrandModelItem {
        data = typeof data === 'object' ? data : {};
        let result = new BrandModelItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelId"] = this.modelId;
        data["name"] = this.name;
        return data;
    }
}

export interface IBrandModelItem {
    modelId?: string;
    name?: string;
}

export class GetVehiclesQueryResponse implements IGetVehiclesQueryResponse {
    responseList?: VehicleItem[];

    constructor(data?: IGetVehiclesQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["responseList"])) {
                this.responseList = [] as any;
                for (let item of _data["responseList"])
                    this.responseList!.push(VehicleItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetVehiclesQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetVehiclesQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.responseList)) {
            data["responseList"] = [];
            for (let item of this.responseList)
                data["responseList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetVehiclesQueryResponse {
    responseList?: VehicleItem[];
}

export class VehicleItem implements IVehicleItem {
    id?: string;
    vehicle?: string;
    plates?: string;
    packages?: string[];

    constructor(data?: IVehicleItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicle = _data["vehicle"];
            this.plates = _data["plates"];
            if (Array.isArray(_data["packages"])) {
                this.packages = [] as any;
                for (let item of _data["packages"])
                    this.packages!.push(item);
            }
        }
    }

    static fromJS(data: any): VehicleItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicle"] = this.vehicle;
        data["plates"] = this.plates;
        if (Array.isArray(this.packages)) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item);
        }
        return data;
    }
}

export interface IVehicleItem {
    id?: string;
    vehicle?: string;
    plates?: string;
    packages?: string[];
}

export class GetVehicleQueryResponse implements IGetVehicleQueryResponse {
    id?: string;
    vehicle?: string;
    plates?: string;
    year?: number | undefined;
    color?: string | undefined;
    chassis?: string | undefined;
    vehicleTypeId?: string;
    vehicleBrandId?: string;
    vehicleModel?: VehicleModelItem;
    packages?: PackageItem[];

    constructor(data?: IGetVehicleQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicle = _data["vehicle"];
            this.plates = _data["plates"];
            this.year = _data["year"];
            this.color = _data["color"];
            this.chassis = _data["chassis"];
            this.vehicleTypeId = _data["vehicleTypeId"];
            this.vehicleBrandId = _data["vehicleBrandId"];
            this.vehicleModel = _data["vehicleModel"] ? VehicleModelItem.fromJS(_data["vehicleModel"]) : <any>undefined;
            if (Array.isArray(_data["packages"])) {
                this.packages = [] as any;
                for (let item of _data["packages"])
                    this.packages!.push(PackageItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetVehicleQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetVehicleQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicle"] = this.vehicle;
        data["plates"] = this.plates;
        data["year"] = this.year;
        data["color"] = this.color;
        data["chassis"] = this.chassis;
        data["vehicleTypeId"] = this.vehicleTypeId;
        data["vehicleBrandId"] = this.vehicleBrandId;
        data["vehicleModel"] = this.vehicleModel ? this.vehicleModel.toJSON() : <any>undefined;
        if (Array.isArray(this.packages)) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetVehicleQueryResponse {
    id?: string;
    vehicle?: string;
    plates?: string;
    year?: number | undefined;
    color?: string | undefined;
    chassis?: string | undefined;
    vehicleTypeId?: string;
    vehicleBrandId?: string;
    vehicleModel?: VehicleModelItem;
    packages?: PackageItem[];
}

export class VehicleModelItem implements IVehicleModelItem {
    modelId?: string | undefined;
    name?: string;

    constructor(data?: IVehicleModelItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modelId = _data["modelId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): VehicleModelItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleModelItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelId"] = this.modelId;
        data["name"] = this.name;
        return data;
    }
}

export interface IVehicleModelItem {
    modelId?: string | undefined;
    name?: string;
}

export class PackageItem implements IPackageItem {
    id?: string;
    name?: string;
    description?: string | undefined;
    price?: number;
    priceId?: string;
    imageUri?: string;
    webPageUrl?: string;
    details?: (string | undefined)[];

    constructor(data?: IPackageItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.priceId = _data["priceId"];
            this.imageUri = _data["imageUri"];
            this.webPageUrl = _data["webPageUrl"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(item);
            }
        }
    }

    static fromJS(data: any): PackageItem {
        data = typeof data === 'object' ? data : {};
        let result = new PackageItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["priceId"] = this.priceId;
        data["imageUri"] = this.imageUri;
        data["webPageUrl"] = this.webPageUrl;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        return data;
    }
}

export interface IPackageItem {
    id?: string;
    name?: string;
    description?: string | undefined;
    price?: number;
    priceId?: string;
    imageUri?: string;
    webPageUrl?: string;
    details?: (string | undefined)[];
}

export class AddLicencePlateCommand implements IAddLicencePlateCommand {
    licencePlate!: string;

    constructor(data?: IAddLicencePlateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.licencePlate = _data["licencePlate"];
        }
    }

    static fromJS(data: any): AddLicencePlateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddLicencePlateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["licencePlate"] = this.licencePlate;
        return data;
    }
}

export interface IAddLicencePlateCommand {
    licencePlate: string;
}

export class DeleteLicencePlateCommand implements IDeleteLicencePlateCommand {
    vehicleId!: string;

    constructor(data?: IDeleteLicencePlateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"];
        }
    }

    static fromJS(data: any): DeleteLicencePlateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteLicencePlateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId;
        return data;
    }
}

export interface IDeleteLicencePlateCommand {
    vehicleId: string;
}

export class RegisterClientPersonCommand implements IRegisterClientPersonCommand {
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string;
    confirmedPassword!: string;
    verificationCode!: string;

    constructor(data?: IRegisterClientPersonCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmedPassword = _data["confirmedPassword"];
            this.verificationCode = _data["verificationCode"];
        }
    }

    static fromJS(data: any): RegisterClientPersonCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterClientPersonCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmedPassword"] = this.confirmedPassword;
        data["verificationCode"] = this.verificationCode;
        return data;
    }
}

export interface IRegisterClientPersonCommand {
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    confirmedPassword: string;
    verificationCode: string;
}

export class AddVehicleCommand implements IAddVehicleCommand {
    vehicleType!: string;
    vehicleBrand!: string;
    vehicleModel!: BrandModelItem;
    productionYear!: string;
    color!: string;
    registrationNumber!: string;
    chassisNumber?: string;

    constructor(data?: IAddVehicleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.vehicleModel = new BrandModelItem();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleType = _data["vehicleType"];
            this.vehicleBrand = _data["vehicleBrand"];
            this.vehicleModel = _data["vehicleModel"] ? BrandModelItem.fromJS(_data["vehicleModel"]) : new BrandModelItem();
            this.productionYear = _data["productionYear"];
            this.color = _data["color"];
            this.registrationNumber = _data["registrationNumber"];
            this.chassisNumber = _data["chassisNumber"];
        }
    }

    static fromJS(data: any): AddVehicleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddVehicleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleType"] = this.vehicleType;
        data["vehicleBrand"] = this.vehicleBrand;
        data["vehicleModel"] = this.vehicleModel ? this.vehicleModel.toJSON() : <any>undefined;
        data["productionYear"] = this.productionYear;
        data["color"] = this.color;
        data["registrationNumber"] = this.registrationNumber;
        data["chassisNumber"] = this.chassisNumber;
        return data;
    }
}

export interface IAddVehicleCommand {
    vehicleType: string;
    vehicleBrand: string;
    vehicleModel: BrandModelItem;
    productionYear: string;
    color: string;
    registrationNumber: string;
    chassisNumber?: string;
}

export class UpdateVehicleCommand implements IUpdateVehicleCommand {
    vehicleId?: string;
    vehicleBrand!: string;
    vehicleModel!: BrandModelItem;
    productionYear!: string;
    color!: string;
    registrationNumber!: string;
    chassisNumber?: string;

    constructor(data?: IUpdateVehicleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.vehicleModel = new BrandModelItem();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"];
            this.vehicleBrand = _data["vehicleBrand"];
            this.vehicleModel = _data["vehicleModel"] ? BrandModelItem.fromJS(_data["vehicleModel"]) : new BrandModelItem();
            this.productionYear = _data["productionYear"];
            this.color = _data["color"];
            this.registrationNumber = _data["registrationNumber"];
            this.chassisNumber = _data["chassisNumber"];
        }
    }

    static fromJS(data: any): UpdateVehicleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVehicleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId;
        data["vehicleBrand"] = this.vehicleBrand;
        data["vehicleModel"] = this.vehicleModel ? this.vehicleModel.toJSON() : <any>undefined;
        data["productionYear"] = this.productionYear;
        data["color"] = this.color;
        data["registrationNumber"] = this.registrationNumber;
        data["chassisNumber"] = this.chassisNumber;
        return data;
    }
}

export interface IUpdateVehicleCommand {
    vehicleId?: string;
    vehicleBrand: string;
    vehicleModel: BrandModelItem;
    productionYear: string;
    color: string;
    registrationNumber: string;
    chassisNumber?: string;
}

export class GetProfileResponse implements IGetProfileResponse {
    userId?: string;
    imageUrl?: string | undefined;
    nationalNumber?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IGetProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.imageUrl = _data["imageUrl"];
            this.nationalNumber = _data["nationalNumber"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): GetProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["imageUrl"] = this.imageUrl;
        data["nationalNumber"] = this.nationalNumber;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IGetProfileResponse {
    userId?: string;
    imageUrl?: string | undefined;
    nationalNumber?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
}

export class UpdateProfileCommand implements IUpdateProfileCommand {
    name!: string;
    lastName!: string;
    nationalNumber?: string | undefined;
    phoneNumber!: string;

    constructor(data?: IUpdateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.nationalNumber = _data["nationalNumber"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["nationalNumber"] = this.nationalNumber;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IUpdateProfileCommand {
    name: string;
    lastName: string;
    nationalNumber?: string | undefined;
    phoneNumber: string;
}

export class SendVerificationEmailCommand implements ISendVerificationEmailCommand {
    email?: string;

    constructor(data?: ISendVerificationEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): SendVerificationEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface ISendVerificationEmailCommand {
    email?: string;
}

export class VerifyRegistrationEmailCommand extends SendVerificationEmailCommand implements IVerifyRegistrationEmailCommand {

    constructor(data?: IVerifyRegistrationEmailCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): VerifyRegistrationEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyRegistrationEmailCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IVerifyRegistrationEmailCommand extends ISendVerificationEmailCommand {
}

export class GetPartnersResponse implements IGetPartnersResponse {
    responseList?: PartnerResponseItem[];

    constructor(data?: IGetPartnersResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["responseList"])) {
                this.responseList = [] as any;
                for (let item of _data["responseList"])
                    this.responseList!.push(PartnerResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPartnersResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPartnersResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.responseList)) {
            data["responseList"] = [];
            for (let item of this.responseList)
                data["responseList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPartnersResponse {
    responseList?: PartnerResponseItem[];
}

export class PartnerResponseItem implements IPartnerResponseItem {
    name?: string;
    imageUrl?: string | undefined;
    contactPhone?: string;
    contactPerson?: string;
    email?: string | undefined;
    isActive?: boolean;
    pricePerKm?: number | undefined;
    maxKgCapacity?: (number | undefined)[];
    maxPassengerCapacity?: (number | undefined)[];

    constructor(data?: IPartnerResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.imageUrl = _data["imageUrl"];
            this.contactPhone = _data["contactPhone"];
            this.contactPerson = _data["contactPerson"];
            this.email = _data["email"];
            this.isActive = _data["isActive"];
            this.pricePerKm = _data["pricePerKm"];
            if (Array.isArray(_data["maxKgCapacity"])) {
                this.maxKgCapacity = [] as any;
                for (let item of _data["maxKgCapacity"])
                    this.maxKgCapacity!.push(item);
            }
            if (Array.isArray(_data["maxPassengerCapacity"])) {
                this.maxPassengerCapacity = [] as any;
                for (let item of _data["maxPassengerCapacity"])
                    this.maxPassengerCapacity!.push(item);
            }
        }
    }

    static fromJS(data: any): PartnerResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["imageUrl"] = this.imageUrl;
        data["contactPhone"] = this.contactPhone;
        data["contactPerson"] = this.contactPerson;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        data["pricePerKm"] = this.pricePerKm;
        if (Array.isArray(this.maxKgCapacity)) {
            data["maxKgCapacity"] = [];
            for (let item of this.maxKgCapacity)
                data["maxKgCapacity"].push(item);
        }
        if (Array.isArray(this.maxPassengerCapacity)) {
            data["maxPassengerCapacity"] = [];
            for (let item of this.maxPassengerCapacity)
                data["maxPassengerCapacity"].push(item);
        }
        return data;
    }
}

export interface IPartnerResponseItem {
    name?: string;
    imageUrl?: string | undefined;
    contactPhone?: string;
    contactPerson?: string;
    email?: string | undefined;
    isActive?: boolean;
    pricePerKm?: number | undefined;
    maxKgCapacity?: (number | undefined)[];
    maxPassengerCapacity?: (number | undefined)[];
}

export class GetPartnersQuery implements IGetPartnersQuery {
    partnerName?: string | undefined;
    isActive?: boolean;

    constructor(data?: IGetPartnersQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partnerName = _data["partnerName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetPartnersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPartnersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partnerName"] = this.partnerName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetPartnersQuery {
    partnerName?: string | undefined;
    isActive?: boolean;
}

export class ActivatePartnersCommand implements IActivatePartnersCommand {
    partnerId?: string;

    constructor(data?: IActivatePartnersCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partnerId = _data["partnerId"];
        }
    }

    static fromJS(data: any): ActivatePartnersCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ActivatePartnersCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partnerId"] = this.partnerId;
        return data;
    }
}

export interface IActivatePartnersCommand {
    partnerId?: string;
}

export class DeactivatePartnersCommand implements IDeactivatePartnersCommand {
    partnerId?: string;

    constructor(data?: IDeactivatePartnersCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partnerId = _data["partnerId"];
        }
    }

    static fromJS(data: any): DeactivatePartnersCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeactivatePartnersCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partnerId"] = this.partnerId;
        return data;
    }
}

export interface IDeactivatePartnersCommand {
    partnerId?: string;
}

export class EditPartnerCommand implements IEditPartnerCommand {
    partnerId!: string;
    name!: string;
    taxId!: string;
    nationalNumber!: string;
    bankAccountNum!: string;
    contactPerson!: string;
    contactEmail!: string;
    contactNumber!: string;
    partnerType!: PartnerType;
    serviceIds!: string[];
    vehicleItems?: CreatePartnerVehicleDto[];

    constructor(data?: IEditPartnerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.serviceIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partnerId = _data["partnerId"];
            this.name = _data["name"];
            this.taxId = _data["taxId"];
            this.nationalNumber = _data["nationalNumber"];
            this.bankAccountNum = _data["bankAccountNum"];
            this.contactPerson = _data["contactPerson"];
            this.contactEmail = _data["contactEmail"];
            this.contactNumber = _data["contactNumber"];
            this.partnerType = _data["partnerType"];
            if (Array.isArray(_data["serviceIds"])) {
                this.serviceIds = [] as any;
                for (let item of _data["serviceIds"])
                    this.serviceIds!.push(item);
            }
            if (Array.isArray(_data["vehicleItems"])) {
                this.vehicleItems = [] as any;
                for (let item of _data["vehicleItems"])
                    this.vehicleItems!.push(CreatePartnerVehicleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditPartnerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditPartnerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partnerId"] = this.partnerId;
        data["name"] = this.name;
        data["taxId"] = this.taxId;
        data["nationalNumber"] = this.nationalNumber;
        data["bankAccountNum"] = this.bankAccountNum;
        data["contactPerson"] = this.contactPerson;
        data["contactEmail"] = this.contactEmail;
        data["contactNumber"] = this.contactNumber;
        data["partnerType"] = this.partnerType;
        if (Array.isArray(this.serviceIds)) {
            data["serviceIds"] = [];
            for (let item of this.serviceIds)
                data["serviceIds"].push(item);
        }
        if (Array.isArray(this.vehicleItems)) {
            data["vehicleItems"] = [];
            for (let item of this.vehicleItems)
                data["vehicleItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditPartnerCommand {
    partnerId: string;
    name: string;
    taxId: string;
    nationalNumber: string;
    bankAccountNum: string;
    contactPerson: string;
    contactEmail: string;
    contactNumber: string;
    partnerType: PartnerType;
    serviceIds: string[];
    vehicleItems?: CreatePartnerVehicleDto[];
}

export enum PartnerType {
    REGULAR = 0,
    BOSCH_CAR = 1,
    AUTH_SERVICE = 1,
}

export class CreatePartnerVehicleDto implements ICreatePartnerVehicleDto {
    vehicleType?: string;
    vehicleBrand!: string;
    vehicleModelId!: string;
    vehicleModelName!: string;
    licencePlate!: string;
    maxWeight!: number;
    numOfSeats!: number;
    pricePerkm!: number;
    longitude!: string;
    latitude!: string;
    address!: string;
    additionalContactName!: string | undefined;
    additionalContactPhoneNum!: string | undefined;

    constructor(data?: ICreatePartnerVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleType = _data["vehicleType"];
            this.vehicleBrand = _data["vehicleBrand"];
            this.vehicleModelId = _data["vehicleModelId"];
            this.vehicleModelName = _data["vehicleModelName"];
            this.licencePlate = _data["licencePlate"];
            this.maxWeight = _data["maxWeight"];
            this.numOfSeats = _data["numOfSeats"];
            this.pricePerkm = _data["pricePerkm"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.address = _data["address"];
            this.additionalContactName = _data["additionalContactName"];
            this.additionalContactPhoneNum = _data["additionalContactPhoneNum"];
        }
    }

    static fromJS(data: any): CreatePartnerVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePartnerVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleType"] = this.vehicleType;
        data["vehicleBrand"] = this.vehicleBrand;
        data["vehicleModelId"] = this.vehicleModelId;
        data["vehicleModelName"] = this.vehicleModelName;
        data["licencePlate"] = this.licencePlate;
        data["maxWeight"] = this.maxWeight;
        data["numOfSeats"] = this.numOfSeats;
        data["pricePerkm"] = this.pricePerkm;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["address"] = this.address;
        data["additionalContactName"] = this.additionalContactName;
        data["additionalContactPhoneNum"] = this.additionalContactPhoneNum;
        return data;
    }
}

export interface ICreatePartnerVehicleDto {
    vehicleType?: string;
    vehicleBrand: string;
    vehicleModelId: string;
    vehicleModelName: string;
    licencePlate: string;
    maxWeight: number;
    numOfSeats: number;
    pricePerkm: number;
    longitude: string;
    latitude: string;
    address: string;
    additionalContactName: string | undefined;
    additionalContactPhoneNum: string | undefined;
}

export class CreatePartnerCommand implements ICreatePartnerCommand {
    name!: string;
    taxId!: string;
    nationalNumber!: string;
    bankAccountNum!: string;
    contactPerson!: string;
    contactEmail!: string;
    contactNumber!: string;
    partnerType!: PartnerType;
    activityTypeIds!: string[];
    vehicles?: PartnerVehicleDto[];

    constructor(data?: ICreatePartnerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activityTypeIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.taxId = _data["taxId"];
            this.nationalNumber = _data["nationalNumber"];
            this.bankAccountNum = _data["bankAccountNum"];
            this.contactPerson = _data["contactPerson"];
            this.contactEmail = _data["contactEmail"];
            this.contactNumber = _data["contactNumber"];
            this.partnerType = _data["partnerType"];
            if (Array.isArray(_data["activityTypeIds"])) {
                this.activityTypeIds = [] as any;
                for (let item of _data["activityTypeIds"])
                    this.activityTypeIds!.push(item);
            }
            if (Array.isArray(_data["vehicles"])) {
                this.vehicles = [] as any;
                for (let item of _data["vehicles"])
                    this.vehicles!.push(PartnerVehicleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePartnerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePartnerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["taxId"] = this.taxId;
        data["nationalNumber"] = this.nationalNumber;
        data["bankAccountNum"] = this.bankAccountNum;
        data["contactPerson"] = this.contactPerson;
        data["contactEmail"] = this.contactEmail;
        data["contactNumber"] = this.contactNumber;
        data["partnerType"] = this.partnerType;
        if (Array.isArray(this.activityTypeIds)) {
            data["activityTypeIds"] = [];
            for (let item of this.activityTypeIds)
                data["activityTypeIds"].push(item);
        }
        if (Array.isArray(this.vehicles)) {
            data["vehicles"] = [];
            for (let item of this.vehicles)
                data["vehicles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatePartnerCommand {
    name: string;
    taxId: string;
    nationalNumber: string;
    bankAccountNum: string;
    contactPerson: string;
    contactEmail: string;
    contactNumber: string;
    partnerType: PartnerType;
    activityTypeIds: string[];
    vehicles?: PartnerVehicleDto[];
}

export class PartnerVehicleDto implements IPartnerVehicleDto {
    vehicleType!: string;
    vehicleBrand!: string;
    vehicleModelId!: string;
    vehicleModelName!: string;
    licencePlate!: string;
    maxWeight?: number | undefined;
    numOfSeats?: number | undefined;
    pricePerkm!: number;
    longitude!: string;
    latitude!: string;
    address!: string;
    additionalContactName?: string | undefined;
    additionalContactPhoneNum?: string | undefined;

    constructor(data?: IPartnerVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleType = _data["vehicleType"];
            this.vehicleBrand = _data["vehicleBrand"];
            this.vehicleModelId = _data["vehicleModelId"];
            this.vehicleModelName = _data["vehicleModelName"];
            this.licencePlate = _data["licencePlate"];
            this.maxWeight = _data["maxWeight"];
            this.numOfSeats = _data["numOfSeats"];
            this.pricePerkm = _data["pricePerkm"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.address = _data["address"];
            this.additionalContactName = _data["additionalContactName"];
            this.additionalContactPhoneNum = _data["additionalContactPhoneNum"];
        }
    }

    static fromJS(data: any): PartnerVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleType"] = this.vehicleType;
        data["vehicleBrand"] = this.vehicleBrand;
        data["vehicleModelId"] = this.vehicleModelId;
        data["vehicleModelName"] = this.vehicleModelName;
        data["licencePlate"] = this.licencePlate;
        data["maxWeight"] = this.maxWeight;
        data["numOfSeats"] = this.numOfSeats;
        data["pricePerkm"] = this.pricePerkm;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["address"] = this.address;
        data["additionalContactName"] = this.additionalContactName;
        data["additionalContactPhoneNum"] = this.additionalContactPhoneNum;
        return data;
    }
}

export interface IPartnerVehicleDto {
    vehicleType: string;
    vehicleBrand: string;
    vehicleModelId: string;
    vehicleModelName: string;
    licencePlate: string;
    maxWeight?: number | undefined;
    numOfSeats?: number | undefined;
    pricePerkm: number;
    longitude: string;
    latitude: string;
    address: string;
    additionalContactName?: string | undefined;
    additionalContactPhoneNum?: string | undefined;
}

export class CreatePackageCommand implements ICreatePackageCommand {
    name!: string;
    description?: string | undefined;
    isVehicleRequired!: boolean;
    isClientIdRequired!: boolean;
    vehicleTypes!: string[];
    packageServices?: string[];
    packageDetails?: string[];
    packagePrices?: PackagePrice[];

    constructor(data?: ICreatePackageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.vehicleTypes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.isVehicleRequired = _data["isVehicleRequired"];
            this.isClientIdRequired = _data["isClientIdRequired"];
            if (Array.isArray(_data["vehicleTypes"])) {
                this.vehicleTypes = [] as any;
                for (let item of _data["vehicleTypes"])
                    this.vehicleTypes!.push(item);
            }
            if (Array.isArray(_data["packageServices"])) {
                this.packageServices = [] as any;
                for (let item of _data["packageServices"])
                    this.packageServices!.push(item);
            }
            if (Array.isArray(_data["packageDetails"])) {
                this.packageDetails = [] as any;
                for (let item of _data["packageDetails"])
                    this.packageDetails!.push(item);
            }
            if (Array.isArray(_data["packagePrices"])) {
                this.packagePrices = [] as any;
                for (let item of _data["packagePrices"])
                    this.packagePrices!.push(PackagePrice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePackageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePackageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isVehicleRequired"] = this.isVehicleRequired;
        data["isClientIdRequired"] = this.isClientIdRequired;
        if (Array.isArray(this.vehicleTypes)) {
            data["vehicleTypes"] = [];
            for (let item of this.vehicleTypes)
                data["vehicleTypes"].push(item);
        }
        if (Array.isArray(this.packageServices)) {
            data["packageServices"] = [];
            for (let item of this.packageServices)
                data["packageServices"].push(item);
        }
        if (Array.isArray(this.packageDetails)) {
            data["packageDetails"] = [];
            for (let item of this.packageDetails)
                data["packageDetails"].push(item);
        }
        if (Array.isArray(this.packagePrices)) {
            data["packagePrices"] = [];
            for (let item of this.packagePrices)
                data["packagePrices"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatePackageCommand {
    name: string;
    description?: string | undefined;
    isVehicleRequired: boolean;
    isClientIdRequired: boolean;
    vehicleTypes: string[];
    packageServices?: string[];
    packageDetails?: string[];
    packagePrices?: PackagePrice[];
}

export class PackagePrice implements IPackagePrice {
    id?: string;
    price?: number;
    description?: string;
    displayOnMobile?: boolean;

    constructor(data?: IPackagePrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.description = _data["description"];
            this.displayOnMobile = _data["displayOnMobile"];
        }
    }

    static fromJS(data: any): PackagePrice {
        data = typeof data === 'object' ? data : {};
        let result = new PackagePrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["description"] = this.description;
        data["displayOnMobile"] = this.displayOnMobile;
        return data;
    }
}

export interface IPackagePrice {
    id?: string;
    price?: number;
    description?: string;
    displayOnMobile?: boolean;
}

export class EditPackageCommand implements IEditPackageCommand {
    id!: string;
    name!: string;
    description?: string | undefined;
    isVehicleRequired?: boolean;
    isClientIdNumberRequired?: boolean;
    vehicleTypes?: string[];
    packageServices?: string[];
    packageDetails?: string[];
    packagePrices?: PackagePrice[];

    constructor(data?: IEditPackageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isVehicleRequired = _data["isVehicleRequired"];
            this.isClientIdNumberRequired = _data["isClientIdNumberRequired"];
            if (Array.isArray(_data["vehicleTypes"])) {
                this.vehicleTypes = [] as any;
                for (let item of _data["vehicleTypes"])
                    this.vehicleTypes!.push(item);
            }
            if (Array.isArray(_data["packageServices"])) {
                this.packageServices = [] as any;
                for (let item of _data["packageServices"])
                    this.packageServices!.push(item);
            }
            if (Array.isArray(_data["packageDetails"])) {
                this.packageDetails = [] as any;
                for (let item of _data["packageDetails"])
                    this.packageDetails!.push(item);
            }
            if (Array.isArray(_data["packagePrices"])) {
                this.packagePrices = [] as any;
                for (let item of _data["packagePrices"])
                    this.packagePrices!.push(PackagePrice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditPackageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditPackageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isVehicleRequired"] = this.isVehicleRequired;
        data["isClientIdNumberRequired"] = this.isClientIdNumberRequired;
        if (Array.isArray(this.vehicleTypes)) {
            data["vehicleTypes"] = [];
            for (let item of this.vehicleTypes)
                data["vehicleTypes"].push(item);
        }
        if (Array.isArray(this.packageServices)) {
            data["packageServices"] = [];
            for (let item of this.packageServices)
                data["packageServices"].push(item);
        }
        if (Array.isArray(this.packageDetails)) {
            data["packageDetails"] = [];
            for (let item of this.packageDetails)
                data["packageDetails"].push(item);
        }
        if (Array.isArray(this.packagePrices)) {
            data["packagePrices"] = [];
            for (let item of this.packagePrices)
                data["packagePrices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditPackageCommand {
    id: string;
    name: string;
    description?: string | undefined;
    isVehicleRequired?: boolean;
    isClientIdNumberRequired?: boolean;
    vehicleTypes?: string[];
    packageServices?: string[];
    packageDetails?: string[];
    packagePrices?: PackagePrice[];
}

export class CreateOrderCommand implements ICreateOrderCommand {
    priceIds!: string[];
    vehicleId?: string | undefined;

    constructor(data?: ICreateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.priceIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priceIds"])) {
                this.priceIds = [] as any;
                for (let item of _data["priceIds"])
                    this.priceIds!.push(item);
            }
            this.vehicleId = _data["vehicleId"];
        }
    }

    static fromJS(data: any): CreateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priceIds)) {
            data["priceIds"] = [];
            for (let item of this.priceIds)
                data["priceIds"].push(item);
        }
        data["vehicleId"] = this.vehicleId;
        return data;
    }
}

export interface ICreateOrderCommand {
    priceIds: string[];
    vehicleId?: string | undefined;
}

export class TokenResponse implements ITokenResponse {
    token?: string;
    refreshToken?: string;
    refreshTokenExpiryTime?: Date;

    constructor(data?: ITokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpiryTime = _data["refreshTokenExpiryTime"] ? new Date(_data["refreshTokenExpiryTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpiryTime"] = this.refreshTokenExpiryTime ? this.refreshTokenExpiryTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITokenResponse {
    token?: string;
    refreshToken?: string;
    refreshTokenExpiryTime?: Date;
}

export class ErrorResult implements IErrorResult {
    messages?: string[] | undefined;
    source?: string | undefined;
    exception?: string | undefined;
    errorId?: string | undefined;
    supportMessage?: string | undefined;
    statusCode?: number;

    constructor(data?: IErrorResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            this.source = _data["source"];
            this.exception = _data["exception"];
            this.errorId = _data["errorId"];
            this.supportMessage = _data["supportMessage"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): ErrorResult {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["source"] = this.source;
        data["exception"] = this.exception;
        data["errorId"] = this.errorId;
        data["supportMessage"] = this.supportMessage;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IErrorResult {
    messages?: string[] | undefined;
    source?: string | undefined;
    exception?: string | undefined;
    errorId?: string | undefined;
    supportMessage?: string | undefined;
    statusCode?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class LoginCommand implements ILoginCommand {
    email!: string;
    password!: string;
    deviceToken?: string | undefined;
    ipAddress?: string;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.deviceToken = _data["deviceToken"];
            this.ipAddress = _data["ipAddress"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["deviceToken"] = this.deviceToken;
        data["ipAddress"] = this.ipAddress;
        return data;
    }
}

export interface ILoginCommand {
    email: string;
    password: string;
    deviceToken?: string | undefined;
    ipAddress?: string;
}

export class ExternalLoginCommand implements IExternalLoginCommand {
    provider!: string;
    idToken!: string;
    deviceToken?: string | undefined;
    ipAddress?: string;

    constructor(data?: IExternalLoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.idToken = _data["idToken"];
            this.deviceToken = _data["deviceToken"];
            this.ipAddress = _data["ipAddress"];
        }
    }

    static fromJS(data: any): ExternalLoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["idToken"] = this.idToken;
        data["deviceToken"] = this.deviceToken;
        data["ipAddress"] = this.ipAddress;
        return data;
    }
}

export interface IExternalLoginCommand {
    provider: string;
    idToken: string;
    deviceToken?: string | undefined;
    ipAddress?: string;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
    token!: string;
    refreshToken!: string;
    ipAddress?: string;

    constructor(data?: IRefreshTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.ipAddress = _data["ipAddress"];
        }
    }

    static fromJS(data: any): RefreshTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["ipAddress"] = this.ipAddress;
        return data;
    }
}

export interface IRefreshTokenCommand {
    token: string;
    refreshToken: string;
    ipAddress?: string;
}

export class AppleLoginCommand extends ExternalLoginCommand implements IAppleLoginCommand {
    givenName?: string | undefined;
    familyName?: string | undefined;

    constructor(data?: IAppleLoginCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.givenName = _data["givenName"];
            this.familyName = _data["familyName"];
        }
    }

    static override fromJS(data: any): AppleLoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AppleLoginCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["givenName"] = this.givenName;
        data["familyName"] = this.familyName;
        super.toJSON(data);
        return data;
    }
}

export interface IAppleLoginCommand extends IExternalLoginCommand {
    givenName?: string | undefined;
    familyName?: string | undefined;
}

export class VerifyPasswordResetEmailCommand extends SendVerificationEmailCommand implements IVerifyPasswordResetEmailCommand {

    constructor(data?: IVerifyPasswordResetEmailCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): VerifyPasswordResetEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyPasswordResetEmailCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IVerifyPasswordResetEmailCommand extends ISendVerificationEmailCommand {
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    email!: string;
    password!: string;
    confirmedPassword!: string;
    verificationCode!: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmedPassword = _data["confirmedPassword"];
            this.verificationCode = _data["verificationCode"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmedPassword"] = this.confirmedPassword;
        data["verificationCode"] = this.verificationCode;
        return data;
    }
}

export interface IResetPasswordCommand {
    email: string;
    password: string;
    confirmedPassword: string;
    verificationCode: string;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
    password!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordCommand {
    password: string;
    newPassword: string;
}

export class PaginationResponseOfEmployeeItem implements IPaginationResponseOfEmployeeItem {
    data?: EmployeeItem[];
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginationResponseOfEmployeeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EmployeeItem.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginationResponseOfEmployeeItem {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationResponseOfEmployeeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginationResponseOfEmployeeItem {
    data?: EmployeeItem[];
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class EmployeeItem implements IEmployeeItem {
    id?: string;
    name?: string;
    lastName?: string | undefined;
    email?: string | undefined;
    imageUrl?: string | undefined;
    createdOn?: string;
    role?: string | undefined;

    constructor(data?: IEmployeeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.imageUrl = _data["imageUrl"];
            this.createdOn = _data["createdOn"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): EmployeeItem {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["imageUrl"] = this.imageUrl;
        data["createdOn"] = this.createdOn;
        data["role"] = this.role;
        return data;
    }
}

export interface IEmployeeItem {
    id?: string;
    name?: string;
    lastName?: string | undefined;
    email?: string | undefined;
    imageUrl?: string | undefined;
    createdOn?: string;
    role?: string | undefined;
}

export class BaseFilter implements IBaseFilter {
    advancedSearch?: Search | undefined;
    keyword?: string | undefined;

    constructor(data?: IBaseFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advancedSearch = _data["advancedSearch"] ? Search.fromJS(_data["advancedSearch"]) : <any>undefined;
            this.keyword = _data["keyword"];
        }
    }

    static fromJS(data: any): BaseFilter {
        data = typeof data === 'object' ? data : {};
        let result = new BaseFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advancedSearch"] = this.advancedSearch ? this.advancedSearch.toJSON() : <any>undefined;
        data["keyword"] = this.keyword;
        return data;
    }
}

export interface IBaseFilter {
    advancedSearch?: Search | undefined;
    keyword?: string | undefined;
}

export class PaginationFilter extends BaseFilter implements IPaginationFilter {
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IPaginationFilter) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static override fromJS(data: any): PaginationFilter {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        super.toJSON(data);
        return data;
    }
}

export interface IPaginationFilter extends IBaseFilter {
    pageNumber?: number;
    pageSize?: number;
}

export class GetEmployeesTableQuery extends PaginationFilter implements IGetEmployeesTableQuery {
    employeeName?: string | undefined;
    isActive?: boolean | undefined;
    userRole?: string;

    constructor(data?: IGetEmployeesTableQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.employeeName = _data["employeeName"];
            this.isActive = _data["isActive"];
            this.userRole = _data["userRole"];
        }
    }

    static override fromJS(data: any): GetEmployeesTableQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeesTableQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeName"] = this.employeeName;
        data["isActive"] = this.isActive;
        data["userRole"] = this.userRole;
        super.toJSON(data);
        return data;
    }
}

export interface IGetEmployeesTableQuery extends IPaginationFilter {
    employeeName?: string | undefined;
    isActive?: boolean | undefined;
    userRole?: string;
}

export class Search implements ISearch {
    fields?: string[];
    keyword?: string | undefined;

    constructor(data?: ISearch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(item);
            }
            this.keyword = _data["keyword"];
        }
    }

    static fromJS(data: any): Search {
        data = typeof data === 'object' ? data : {};
        let result = new Search();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item);
        }
        data["keyword"] = this.keyword;
        return data;
    }
}

export interface ISearch {
    fields?: string[];
    keyword?: string | undefined;
}

export class InviteNewEmployeesCommand implements IInviteNewEmployeesCommand {
    employeeRequestList?: EmployeeRequestItem[];

    constructor(data?: IInviteNewEmployeesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["employeeRequestList"])) {
                this.employeeRequestList = [] as any;
                for (let item of _data["employeeRequestList"])
                    this.employeeRequestList!.push(EmployeeRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InviteNewEmployeesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new InviteNewEmployeesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.employeeRequestList)) {
            data["employeeRequestList"] = [];
            for (let item of this.employeeRequestList)
                data["employeeRequestList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInviteNewEmployeesCommand {
    employeeRequestList?: EmployeeRequestItem[];
}

export class EmployeeRequestItem implements IEmployeeRequestItem {
    email!: string;
    roleId!: string;

    constructor(data?: IEmployeeRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): EmployeeRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IEmployeeRequestItem {
    email: string;
    roleId: string;
}

export class DeactivateEmployeesCommand implements IDeactivateEmployeesCommand {
    employeeId?: string;

    constructor(data?: IDeactivateEmployeesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): DeactivateEmployeesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeactivateEmployeesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        return data;
    }
}

export interface IDeactivateEmployeesCommand {
    employeeId?: string;
}

export class ActivateEmployeeAsyncCommand implements IActivateEmployeeAsyncCommand {
    employeeId?: string;

    constructor(data?: IActivateEmployeeAsyncCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): ActivateEmployeeAsyncCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmployeeAsyncCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        return data;
    }
}

export interface IActivateEmployeeAsyncCommand {
    employeeId?: string;
}

export class EditEmployeeCommand implements IEditEmployeeCommand {
    employeeId!: string;
    role!: string;
    isActive!: boolean;

    constructor(data?: IEditEmployeeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.role = _data["role"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EditEmployeeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditEmployeeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["role"] = this.role;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IEditEmployeeCommand {
    employeeId: string;
    role: string;
    isActive: boolean;
}

export class CreateMediumCommand implements ICreateMediumCommand {
    name!: string;
    isSystemDefault?: boolean;

    constructor(data?: ICreateMediumCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSystemDefault = _data["isSystemDefault"];
        }
    }

    static fromJS(data: any): CreateMediumCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMediumCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSystemDefault"] = this.isSystemDefault;
        return data;
    }
}

export interface ICreateMediumCommand {
    name: string;
    isSystemDefault?: boolean;
}

export class DeleteMediumCommand implements IDeleteMediumCommand {
    mediumId!: string;

    constructor(data?: IDeleteMediumCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mediumId = _data["mediumId"];
        }
    }

    static fromJS(data: any): DeleteMediumCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteMediumCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mediumId"] = this.mediumId;
        return data;
    }
}

export interface IDeleteMediumCommand {
    mediumId: string;
}

export class EditMediumCommand implements IEditMediumCommand {
    id!: string;
    name!: string;
    isSystemDefault?: boolean;

    constructor(data?: IEditMediumCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isSystemDefault = _data["isSystemDefault"];
        }
    }

    static fromJS(data: any): EditMediumCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditMediumCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isSystemDefault"] = this.isSystemDefault;
        return data;
    }
}

export interface IEditMediumCommand {
    id: string;
    name: string;
    isSystemDefault?: boolean;
}

export class CreateSourceCommand implements ICreateSourceCommand {
    name!: string;
    isSystemDefault?: boolean;

    constructor(data?: ICreateSourceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSystemDefault = _data["isSystemDefault"];
        }
    }

    static fromJS(data: any): CreateSourceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSourceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSystemDefault"] = this.isSystemDefault;
        return data;
    }
}

export interface ICreateSourceCommand {
    name: string;
    isSystemDefault?: boolean;
}

export class DeleteSourceCommand implements IDeleteSourceCommand {
    sourceId!: string;

    constructor(data?: IDeleteSourceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceId = _data["sourceId"];
        }
    }

    static fromJS(data: any): DeleteSourceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteSourceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        return data;
    }
}

export interface IDeleteSourceCommand {
    sourceId: string;
}

export class EditSourceCommand implements IEditSourceCommand {
    id!: string;
    name!: string;
    isSystemDefault?: boolean;

    constructor(data?: IEditSourceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isSystemDefault = _data["isSystemDefault"];
        }
    }

    static fromJS(data: any): EditSourceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditSourceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isSystemDefault"] = this.isSystemDefault;
        return data;
    }
}

export interface IEditSourceCommand {
    id: string;
    name: string;
    isSystemDefault?: boolean;
}

export class CreateAssistanceCommand implements ICreateAssistanceCommand {
    from?: LocationItem;
    to?: LocationItem;
    failureDescription?: string;
    failureType?: string;
    clientId?: string;
    vehicleId?: string;
    packageId?: string;
    partnerId?: string;
    serviceId?: string;

    constructor(data?: ICreateAssistanceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"] ? LocationItem.fromJS(_data["from"]) : <any>undefined;
            this.to = _data["to"] ? LocationItem.fromJS(_data["to"]) : <any>undefined;
            this.failureDescription = _data["failureDescription"];
            this.failureType = _data["failureType"];
            this.clientId = _data["clientId"];
            this.vehicleId = _data["vehicleId"];
            this.packageId = _data["packageId"];
            this.partnerId = _data["partnerId"];
            this.serviceId = _data["serviceId"];
        }
    }

    static fromJS(data: any): CreateAssistanceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAssistanceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toJSON() : <any>undefined;
        data["to"] = this.to ? this.to.toJSON() : <any>undefined;
        data["failureDescription"] = this.failureDescription;
        data["failureType"] = this.failureType;
        data["clientId"] = this.clientId;
        data["vehicleId"] = this.vehicleId;
        data["packageId"] = this.packageId;
        data["partnerId"] = this.partnerId;
        data["serviceId"] = this.serviceId;
        return data;
    }
}

export interface ICreateAssistanceCommand {
    from?: LocationItem;
    to?: LocationItem;
    failureDescription?: string;
    failureType?: string;
    clientId?: string;
    vehicleId?: string;
    packageId?: string;
    partnerId?: string;
    serviceId?: string;
}

export class LocationItem implements ILocationItem {
    longitude?: number;
    latitude?: number;
    place?: string;

    constructor(data?: ILocationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.place = _data["place"];
        }
    }

    static fromJS(data: any): LocationItem {
        data = typeof data === 'object' ? data : {};
        let result = new LocationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["place"] = this.place;
        return data;
    }
}

export interface ILocationItem {
    longitude?: number;
    latitude?: number;
    place?: string;
}

export class Result<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}